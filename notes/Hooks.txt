

# react hooks

  -> hooks are nothing but normal js utility functions

  #useState() - gives superpower full state variables 
  -> We use it to create state variables


  state variables 
  -> maintains the state of a component

  -> Whenever state variables update/changes   react re-renders the component


  -> react.js is monitoring the state variables as soon as the state updates react.js will trigger (reconciliation cycle) its diff algo finds out the difference between old virtual dom and new virtual dom and then will update the UI and render it 

  # why do we need state variables?
  ->  In react when we use normal js variables to change something in component variables value changes but it does not appear on UI 
    why?
    -> Because it changes the value but it does not trigger (reconciliation cycle) it re-render so UI can be updated

    # This is why we use state variables Whenever the state updates it triggers re-render 

    -> As soon as the state updates entire component re-renders

      #// whenever state variable updates react trigger reconciliation cycle (re-renders the component)

 ***    const [variable, setVariable] = useState("");
   # How can react.js update the const state variable using setVariable()?
    -> When we update the state variables the entire component re-renders 
       -> Because of this new instance of the state variable is created with the updated value 

   #useEffect() - 
   -> It takes 2 arguments 
   ->  useEffect(() => {

   }, []); 

   -> 1. callback function
      2. dependency array

   -> useEffect() will be called after the component is completely rendered/components render cycle is complete/over 
   -> Why does it work like this? -
      -> Because of  callback() when react.js code runs line by line when it comes to useEffect() there is callback() callback() are asynchronous so they are stored in the web API environment until it settles then it will move to the callback queue then event loop which is monitoring the call stack and callback queue continuously checks if call stack is empty or not is it is then only callback() will move in the call stack to execute

      -> In the meantime all of this happening behind the scenes all the js and JSX code will be executed first 

      -> This is why useEffect() will be called after the component is completely rendered


      # use case

      page loads -> component renders -> api call in useEffect -> component re-renders


 ***  imp -
      -> every time component renders useEffect() is called  

      -> useEffect() takes two arguments 
         1. callback function
         2. dependency array
      -> callback() is mandatory

      -> if use dependency array it changes the behavior of its render

      ->  if no dependency array => useEffect() is called on every render

      useEffect(() => {
        console.log();
      }); 

     
      ->  if dependency array is empty => useEffect() is called on initial render(when component is rendered first time) just once
 
      useEffect(() => {
        console.log();
      },[]); 


    ->  if dependency array not empty => first it will be called on initial render and every time  when dependency updates

      useEffect(() => {
        console.log();
      },[name]); 
     

      # unmounting in useEffect()
        -> clearing setInterval

       if we have setInterval in  useEffect it will keep calling it again and again even when we leave the component
       so we need something to clear when we leave the component


        useEffect(() => {
          const timer = setInterval(()=>{
           console.log(" componentDidUpdate");
           },1000);

          return () => {   -> this is the way of unmounting in useEffect()
            clearInterval(timer);
          }

        },[]); 